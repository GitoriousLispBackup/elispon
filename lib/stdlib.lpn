(define nil ())
(define not null?)
(define quote
  (ε args _ (car args)))

(define !
  (ε args e
     (if (not (= (length args) 1))
         (error "!: expecped 1 argument")
         (sequence
           (define fexpr (eval (car args) e))
           (if (not (fexpr? fexpr))
               (error "!: expected fexpr")
               (ε arguments env
                  (apply fexpr (eval (cons list arguments) env))))))))

(define &
  (ε args e
     (if (not (= (length args) 1))
         (error "&: expecped 1 argument")
         (sequence
           (define app (eval (car args) e))
           (if (not (fexpr? app))
               (error "&: expected fexpr")
               (sequence
                 (define fexpr (%open-fexpr% app))
                 (eval (car (cdr (car fexpr))) (cdr fexpr))))))))

(define lambda
  (ε args e
     (! (eval (list ε (car args) (quote _) (car (cdr args))) e))))
(define λ lambda)

(define and
  (ε args e
     (if (null? args)
         t
         (if (= (length args) 1)
             (eval (car args) e)
             (if (eval (car args) e)
                 (apply and (cdr args) e)
                 nil)))))
(define or
  (ε args e
     (if (null? args)
         nil
         (sequence
           (define arg (eval (car args) e))
           (if arg
               arg
               (apply or (cdr args) e))))))

(define cond
  (ε args e
     (if (null? args)
         nil
         (sequence
           (define clause (car args))
           (define len (length clause))
           (if (not (or (= len 2) (= len 3)))
               (error "cond: malformed clause")
               (sequence
                 (define c (eval (car clause) e))
                 (if c
                     (if (and (= len 3)
                              (eq? (car (cdr clause)) (quote =>)))
                         ((eval (car (cdr (cdr clause))) e) c)
                         (eval (car (cdr clause)) e))
                     (apply cond (cdr args) e))))))))

(define let
  (ε args environment
     (if (not (= (length args) 2))
         (error "let: expected 2 arguments")
         (sequence
           (define pattern (car (car args)))
           (define expression (eval (cdr (car args)) environment))
           (define body (car (cdr args)))
           (define new-env
             (lambda pat
               (lambda exp
                 (lambda env
                   (sequence
                     (define p (car pat))
                     (define x (car exp))
                     (define e (car env))
                     (cond
                      ((null? p)
                       (if (not (null? x))
                           (error "let: expression doesn't match pattern")
                           e))
                      ((symbol? p)
                       (cons (cons p x) e))
                      ((pair? p)
                       (if (not (pair? x))
                           (error "let: expression doesn't match pattern")
                           (((new-env (car p)) (car x))
                            (((new-env (cdr p)) (cdr x)) e))))
                      (t (error "let: wrong pattern"))))))))
           (eval body (((new-env pattern) expression) environment))))))

(define list?
  (ε args e
     (let ((l) . args)
       (or (null? l) (pair? l)))))

(define def
  (ε args e
     (apply define
            (list (car (car args))
                  (ε arguments env
                     (let ((cdr (car args)) . arguments)
                       (car (cdr args)))))
            e)))
; TODO fixme (define (foo x) x) -> foo
; foo -> Error: foo: undefined symbol

;; (define $append
;;   (ε args e
;;      (if (not (= (length args) 2))
;;          (error "append: expected 2 arguments")
;;          (sequence
;;            (define lst (car args))
;;            (define obj (car (cdr args)))
;;            (if (null? lst)
;;                (list obj)
;;                (if (not (pair? lst))
;;                    (error "append: expected pair as first argument")
;;                    (cons (car lst)
;;                          (apply $append (list (cdr lst) obj)))))))))
;; (define append (! $append))

;; (define caar
;;   (ε args e
;;      (if (not (= (length args) 1))
;;          (error "caar: expected 1 argument")
;;          (car (car (eval (car args) e))))))

;; (define cadr
;;   (ε args e
;;      (if (not (= (length args) 1))
;;          (error "cadr: expected 1 argument")
;;          (car (cdr (eval (car args) e))))))

;; (define cdar
;;   (ε args e
;;      (if (not (= (length args) 1))
;;          (error "cdar: expected 1 argument")
;;          (cdr (car (eval (car args) e))))))

;; (define cddr
;;   (ε args e
;;      (if (not (= (length args) 1))
;;          (error "cddr: expected 1 argument")
;;          (cdr (cdr (eval (car args) e))))))

;; (define let
;;   (ε args e
;;      (if (not (= (length args) 2))
;;          (error "let: expected 2 arguments")
;;          (eval (cadr args)
;;                (cons (cons (caar args)
;;                            (eval (cdar args) e))
;;                      e)))))

;; (define caaar (λ x (car (caar x))))
;; (define caadr (λ x (car (cadr x))))
;; (define cadar (λ x (car (cdar x))))
;; (define caddr (λ x (car (cddr x))))
;; (define cdaar (λ x (cdr (caar x))))
;; (define cdadr (λ x (cdr (cadr x))))
;; (define cddar (λ x (cdr (cdar x))))
;; (define cdddr (λ x (cdr (cddr x))))

;; (define lazy-cons
;;   (ε args e
;;      (if (not (= (length args) 2))
;;          (error "lazy-cons: expected 2 arguments")
;;          (cons e args))))

;; (define lazy-car
;;   (ε args e
;;      (if (not (= (length args) 1))
;;          (error "lazy-car: expected 1 argument")
;;          (let (c . (eval (car args) e))
;;            (eval (cadr c) (car c))))))

;; (define lazy-cdr
;;   (ε args e
;;      (if (not (= (length args) 1))
;;          (error "lazy-car: expected 1 argument")
;;          (let (c . (eval (car args) e))
;;            (eval (caddr c) (car c))))))
