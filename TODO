Number must have +/-INFINITY flags and take care of cmp to take that into
   account (this to support infinite list).

Printer should check this flag to print accordingly.

---

(define-struct foo (bar baz))
(define lala (make-foo 1 2))
(foo-bar lala) -> 1
(foo-baz lala) -> 2
(foo? lala) -> t
lala -> #<struct:foo>
(type lala) -> foo

or

(define complex (struct r i)) -> complex
complex -> #<struct:complex>
(define c (make complex 4 2)) -> c
c -> #<object:complex>
(is-a? complex c) -> t
(complex r c) -> 4

---

Environment mutation in fexpr fix: rather than a list, an env should be a locat
   possibly empty list, and a pointer to parent. (Something like (cons
   local-assoc parent) if I still want environment to not be encapsulated type)

This would allow to check when returning from eval or fexpr if it's dynamic
   environment has new bindings and then import them.

---

Lexer should return a struct like this:

    struct Token {
      TokenType type;
      union {
        char *str;
        double num;
      } token;
      struct {
        int line, col
      } beg, end;
      char *source;
    }

and most of this information should be keeped at least until expansion time is
   over, maybe during runtime too to report fexpr error if the project goes
   this way

---

(error "message" symbol)

if error primitive have an additionnal argument, also print location info
   extracted from symbol

---

Fix the problem with Environment_delete which fail when trying to delete the
   same thing two times (some stuff like symbols might appear several time
   there)

=> go for a mark-and-sweep GC ?
=> use libgc ?

---

libunistring ?
libffi ?
libreadline ?
libgmp ?
